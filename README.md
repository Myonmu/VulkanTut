## Overview

TL;DR: The bumpy ride of Vulkan Learning.

The *classic* tutorial, named Vulkan Tutorial, is a semi-great place to code in Vulkan, but it comes with a horrific code structure: *everything in one file*.

Hence, the repo tries to mitigate this:

- Vulkan objects will be encapsulated in custom wrappers, and usually they have implicit conversion toward the raw Vulkan object. The wrappers follow RAII.
- Long methods are chopped into smaller chunks
- Better interdependencies between objects

We also use Vulkan Guide as a supplementary reference.

A homebrew OOP version (more specifically, custom RAII wrappers from scratch), is potentially not optimal compared to the official RAII but should allow us to understand better the inner workings of the API.

The repo goes slightly beyond the tutorials by also implementing:

- Player loop updates driven by flecs ECS
- Shader reflection
- Multi-window support

## Installation

The primary IDE used during the development is *CLion*, but *Visual Studio 2022* should work as well. We have only tested building with **MSVC**.

We use *CMake* as our build system.

The repo has changed to use **vcpkg** for package management. Follow [Tutorial: Install and use packages with CMake](https://learn.microsoft.com/en-us/vcpkg/get_started/get-started?pivots=shell-powershell) to configure vcpkg on your system.

## Architecture

### Engine-defined Descriptor Allocation

The first descriptor set (set = 0) is engine-defined, meaning whatever is written in shader **must** match the c++ side definition. All engine defined descriptor sets could be found in `EngineDescriptorDef.cpp`.

*By "engine-defined", it means the data filled in these descriptor sets are automatically managed by the engine.*

To add a new engine defined descriptor binding (an ubo most times):

1. Create a data struct declaring its fields. This will be your descriptor. e.g. `struct { glm::vec4 someField; };`
2. Determine which set, which binding it is. Write accordingly in `EngineDescriptorDef.cpp`. In `EngineDescriptorSetCreateInfo` you need to specify its binding, its contribution to allocator ratio, and the size of the associated buffer. Reminder: descriptor pool allocator allocates descriptors by types, so "contribution to allocator ratio" means increasing the ratio of a specific type of descriptor if the type is already present.
3. Decide how often is the buffer updated. Because of frame overlap (or frames in flight), a per-frame updated resource will need to use `PerFrameDescriptorSet`.
4. Decide when to memcpy into the buffer. For the per-frame descriptor set (set = 0), the update is driven by ecs systems (refer to how camera view projection matrix is transferred to the buffer). You might need to create an ecs component type.
5. Change descriptor set binding call. Currently, it is part of the `MeshRenderer` class.

## Coding Style

The style follows the tutorial, which differs from C++ default stype:

- Classes and Structs are UpperCamelCase
- Members (fields, functions) are lowerCamelCase (with an exceptional house rule)
- Macros and constant numeric values are ALL_CAPS

House rules:

- get methods generated by macros (especially `CTX_PROPERTY`) always follow `get_someField()` syntax. This helps when you try to search for usages as the IDE doesn't collect them - search for "someField" instead
- sometimes, the before-mentionned "get_" syntax may apply to fields that are not generated by macros. This is reserved for a future refactoring.

*example: `get_logicalDevice()` is generated by `CTX_PROPERTY(LogicalDevice, logicalDevice)`, while `getLogicalDevice()` does the same thing but is explicitly implemented as part of the `SubContext` class.*

## Topics

Here, we discuss some less obvious concepts encountered during the learning process. Some specific topics are quite lengthy and have been moved to dedicated files for clarity.

## Table of Contents

- Vulkan Initialization and Surfaces
- VkSwapchainKHR, VkRenderPass, and VkFrameBuffer
- Descriptor Set Layout, Descriptor Pool, Descriptor Set
- Pipeline Layout, Pipeline, Descriptor Sets  (WIP)
- Render Pass and Associated Resources
- Attachment Referencing
- Render Graph Overview (WIP)
- Unreal Engine's Render Dependency Graph (WIP)


### Vulkan Initialization and Surfaces

There is a slightly complex dependency between `VkInstance`, `VkPhysicalDevice`, `VkSurface`, and `VkDevice`, which I believe is not well pronounced in the tutorial. In the tutorial, these are all treated as singletons. However, the only *true singleton* among these objects is `VkInstance`.

Here's how these objects are created in the tutorial:

```  
VkInstance  =>  VkSurface  =>  VkPhysicalDevice  =>  VkDevice  
```  

This illustration might cause confusion if we were rendering to multiple windows, since for each window, we would need a separate `VkSurface` instance, yet a physical device should be shared among these windows, and a logical device is one per physical device. But recall *why* we need to use VkSurface in physical device creation in the first place: *querying queue family indices*, and queue family isn't tied to any specific surface, but to all the surfaces. It is the distinct queue family used by all surfaces.

e.g. Surface A requires `VK_QUEUE_GRAPHICS_BIT` and `VK_QUEUE_VIDEO_DECODE_BIT_KHR`, Surface B requires `VK_QUEUE_GRAPHICS_BIT` and `VK_QUEUE_COMPUTE_BIT`, then what we need to pass to physical device selection is the distinct types : `VK_QUEUE_GRAPHICS_BIT`,`VK_QUEUE_VIDEO_DECODE_BIT_KHR` and `VK_QUEUE_COMPUTE_BIT`.

This provides us with a first insight: allocate all the surfaces we might use before physical device selection, so that we know what queue famillies we expect.

```  
                VkSurface a  \  
                VkSurface b  |         distinct queue family indices  
VkInstance  =>      ...      |---------\  
                    ...      |          |  
                VkSurface n  /          |  
                                        |  
            ---------------- =>  VkPhysicalDevice  =>  VkDevice  
```  

Yet there is another problem. What if we want to spawn a new window after logical device creation?

Theoretically, the newly spawned window (with its own `VkSurface`) might require another queue family that wasn't present in physical device selection or logical device creation. And this would be catastrophic, as there is no way we can dynamically modify physical device nor logical device after their creation. Therefore, we would need to reconstruct  
everything from physical device selection, almost as if you are restarting the whole application.

But how likely would that happen? In most cases, we would expect a dynamically created surface to have queue family requirements already satisfied by the surfaces created before physical device selection. Unless, for example, you *suddenly, unexpectedly* want to encode/decode video in a space shooter. It is very unlikely that you are not sure what  
you want to do in an application, thus in almost any case, you should be able to determine the queue family indices beforehand.

Given that a dynamically spawned window is almost certain to have the same queue family requirements as previous windows, the newly spawned window will not affect existing physical device and logical device. Though it is always better to be prepared for the worst. Adding an error handling mechanism to validate the queue families required by the  
new window should suffice, and when there is indeed a new queue family that isn't present, well, we have no choice but to recreate everything from physical device.

As a generic engine, even if we do not need video encoding/decoding at the moment, we could allocate a surface pre-emptively to avoid the hassle when the end-user suddenly wants to do so.

A final note, it is actually possible to not recreate everything, *if we can find another physical device that suits the needs*. We could simply run the window on another GPU... But that can cause significant headache afterwards as you might want to synchronize between different devices.

### VkSwapchainKHR, VkRenderPass, and VkFrameBuffer

This is perhaps another understated relationship in the tutorial.

`VkSwapchainKHR` is effectively per-window, and in the tutorial, `VkRenderPass` is created with a swapchain's image format, and `VkFrameBuffer` requires both a swapchain's image attachments and be bound to **a single render pass**. And this would create a strong dependency chain on our first sight, though upon closer inspection, not necessarily.

In the tutorial, `VkRenderPass` only requires an image format, but it doesn't state that the image format should come from a swapchain. (Well, actually yes, you *would* use the swapchain's image format, but you don't need to access the swapchain during render pass creation.) Thus instead of accessing swapchain's member field, using a constructor  
Injection would decouple the strong relationship between swapchain and render pass. (Note: constructor injection is just a fancy way to say pass the image format as constructor argument)

This means that multiple swapchains can effectively use the same render pass if their image format and other bits are compatible.

Actually, that's not quite right. since swapchains do not *use* a render pass directly. This relationship comes with `VkFrameBuffer` as it uses both a swapchain and a render pass - we ensure that the swapchain and the render pass are compatible when creating frame buffers, or else we first need to create a compatible render pass. By "compatible, " it isn't just the image format, but also store/load operations, etc.

```  
VkSwapchainKHR  
      \1            VkRenderPass  
       \            /1  
        \*         /*  
        VkFrameBuffer   
```  

The compatibility requirements seem strict, but consider the following scenario: a scene is being rendered with multiple windows, using the same device and likely the same render pipeline. For consistency, there's no reason to fiddle with the render pass parameters, thus, it is likely that we can use the same render pass for all these windows.

*Multi-window rendering reusing the same render pass:*  
![image](https://github.com/user-attachments/assets/26518b13-2121-4658-9564-cda472b0c583)

### Descriptor Set Layout, Descriptor Pool, Descriptor Set

Due to the length of the article, it has been moved to the dedicated file

### Pipeline Layout, Pipeline, Descriptor Sets  (WIP)

Consider this scenario in *Unity*: When we want to create a *Material*, we first right-click on a shader and then click Create Material. This will add a Material asset in the project. And then, we could assign textures, change numbers - all in the inspector of that material asset. Finally, when the material is dragged on a renderer, it exposes a *Material  
Property Block* that can be used to further override the properties.

Despite the lack of source code evidence, we could make an analogy between the Unity terms and Vulkan terms, or how we can use Vulkan concepts to mimic this behavior.

- **Shader Asset**: the inspector of the shader asset suggests a serialized version of shader's reflection data (*Descriptor Bindings*). This data would allow us to construct a *Descriptor Set Layout* and a *Pipeline Layout*.
- **Material Asset**: *Pipeline* and shared *descriptor sets*.
- **Material Property Block**: per-instance *descriptor sets*.

Though, it isn't always true that between *Shader Asset* and *Descriptor Set Layout/Pipeline Layout* is a one-to-one relationship. The only thing that can be directly created from shader code is *Shader Modules*.

Different shades can have the same *Descriptor Set Layout* if they have the same layout declarations (we don't care the variable names except for vertex input), and *Pipeline Layout* can be shared if they only differ in the descriptor's content sets or push constants we  
Provide. This means shader code that only differs in execution can use the same pipeline layout.

Now recall that binding pipeline and binding descriptor sets are two distinct function calls: `vkCmdBindPipeline` and `vkCmdBindDescriptorSets`. descriptor sets are bound to *pipeline layout* rather than pipeline (we bind them according to descriptor set layout, and the descriptor set layout is stored in pipeline layout). This further enhances that `VkPipeline` should be shared, because you could bind a pipeline, and then issue different pipelines with different draw calls

### Render Pass and Associated Resources

The original tutorial has only one render pass with only one subpass. The detailed breakdown of these different components is detailed below in the Render Graph section. Here I would only outline the top-level relationships between Render Pass related concepts.

For each window, we have only one swapchain. This means we can only have a single color output that gets rendered to that window (surface, to be exact). Because of frame overlaps, we have multiple swapchain images, and during each render loop, we acquire one from the swapchain. Now, these swapchian-specific VkImage(s) are created differently, by calling `vkGetSwapchainImagesKHR` (see `PresentColorAttachment`). We then need to write to this specific image during render loop to actually show something on the window.

To use this swapchain image, two things need to be done:

- Reference it in a frame buffer.
- Use the frame buffer in a render pass.

The swapchain image is like any other color attachments, except for being used to present the result. Frame buffer is per-Render Pass, so it means when we have multiple render passes, we don't necessarily write to a swapchain image, it all depends on the declaration of the frame buffer and whether the image is passed to color attachment during render pass and subpass creation.

Well, render pass is created earlier than frame buffers (because we need a render pass reference in frame buffer create info), so logically we create frame buffers based on the declared usages in a render pass. This is an important concept that we use in render graph.

As for subpasses, they are inside render pass and use a subset of the frame buffers. The details are in the Render Graph section.

```  
  Window  
    \                                 RenderPass 1------* Subpass  
     \                                    |           
  Swapchain   ColorAttachments 0*---1 FrameBuffer  
       \1                            /     /  
        \                         01/     /  
         \     DepthStencilAttachment    /  
          \*                            /  
          PresentColorAttachment 01----/  
```  

Render Pass does not directly reference an attachment's handle, but only through *Attachment Description* and *Attachment Reference*, which can exist before the attachment is even created. The actual correspondence is done through the frame buffer (or descriptor sets if not managed by renderpass).

### Attachment Referencing

The Render Pass system has a rather complex attachment referencing mechanism, and one little misalignment will result in painful bug hunting (one more reason to prefer render graph to ensure proper referencing).

There are several orders that are important:

In shader, we have input attachment declared:
```glsl  
layout (input_attachment_index = 0, set = 1, binding = 0) uniform subpassInput inputPosition;  
```  
This means we expect an input attachment at 0, and the same `VkImageView` is bound at binding 0 of descriptor set 1. Now, "input attachment at 0" is a vague description. What is this "0" exactly?

Turns out it is *the index of the attachment reference in Subpass description* - not the index of the attachment in frame buffer:

```c++  
VkSubpassDescription Subpass::getSubpassDescription() const {  
    return {  
         // other fields are not shown   
        .inputAttachmentCount = static_cast<uint32_t>(inputAttachments.size()),  
        .pInputAttachments = inputAttachments.data(), //<- corresponds to index in this vector/array  
    };  
}  
```  

Even if the attachment reference is `{.attachment = 2}`, if it is the first in the attachment reference array, in shader, `input_attachment_index` should be 0.

Now, the `.attachment` in `VkAttachmentReference` points to the index of the attachment in Frame Buffer ... if configured correctly. It actually points to the `.pAttachments` array index in `VkRenderPassCreateInfo`

```c++  
    VkRenderPassCreateInfo renderPassInfo{};  
    renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;  
    renderPassInfo.attachmentCount = static_cast<uint32_t>(descriptions.size());  
    renderPassInfo.pAttachments = descriptions.data();  
    //...  
```  

The order of the `.pAttachments` should be used to create the frame buffer, or else you get a mismatch:

```c++  
    VkFramebufferCreateInfo framebufferInfo{};  
    framebufferInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;  
    framebufferInfo.renderPass = renderPass;  
    framebufferInfo.attachmentCount = static_cast<uint32_t>(attachments.size());  
    framebufferInfo.pAttachments = attachments.data(); //<- order should be the same as in render pass  
    //...  
```  

Since inputs are connected to some outputs, which means the order of the outputs must also follow the next input. This is again specified in Subpass:

```c++  
VkSubpassDescription Subpass::getSubpassDescription() const {  
    return {  
         // other fields are not shown   
        .colorAttachmentCount = static_cast<uint32_t>(colorAttachments.size()),  
        .pColorAttachments = colorAttachments.data(),  
    };  
}  
```  

Finally, the `clearColors` in `VkRenderPassBeginInfo` should also follow the declaration order in `VkRenderPass`, and by extension, the order in frame buffer. If you accidentally give a color texture a depth clear value, then you will see weird things.

![schema: attachment referencing](https://github.com/user-attachments/assets/3304548c-f0ae-4503-9013-d2e9e4b13253)
